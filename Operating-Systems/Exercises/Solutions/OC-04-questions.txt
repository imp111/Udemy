Да се напише shell скрипт, който приканва потребителя да въведе низ (име) и изпечатва "Hello, низ".

#!/bin/bash
read var
echo "Hello $var"


Да се напише shell скрипт, който приема точно един параметър и проверява дали подаденият му параметър се състои само от букви и цифри.

#!/bin/bash
regex="^[a-zA-Z0-9]*$"
if ( echo "${1}" | grep "${regex}" ); then
echo "the String has only digits/letter"
else
 echo "the String has special characters"
fi

Да се напише shell скрипт, който приканва потребителя да въведе низ - потребителско име на потребител от системата - след което извежда на стандартния изход колко активни сесии има потребителят в момента.

#!/bin/bash
trqbva proverka + read
w|grep "$USER"|wc -l

Да се напише shell скрипт, който приканва потребителя да въведе пълното име на директория и извежда на стандартния изход подходящо съобщение за броя на всички файлове и всички директории в нея.

#!/bin/bash
read var
echo "the directories count in this directory is $(find $var -maxdepth 1 -mindepth 1 -type d|wc -l)"
echo "the file count in this directory is $(find $var -maxdepth 1 -type f|wc -l)"
Да се напише shell скрипт, който чете от стандартния вход имената на 3 файла, обединява редовете на първите два (man paste), подрежда ги по азбучен ред и резултата записва в третия файл.

#!/bin/bash
read file1
read file2
read file3
paste $file1 $file2 | sort -d >$file3

Да се напише shell скрипт, който чете от стандартния вход име на файл и символен низ, проверява дали низа се съдържа във файла и извежда на стандартния изход кода на завършване на командата с която сте проверили наличието на низа.

#!/bin/bash
read string
read file
grep "$string" $file 1>/dev/null
echo "$?"

Имате компилируем (a.k.a няма синтактични грешки) source file на езика C. Напишете shell script, който да покaзва колко е дълбоко най-дълбокото nest-ване (влагане). Kakvo se iska ot zadachata?

Напишете shell script, който по подаден като аргумент файл с map между <nickname> -> <реален username> и nickname, ще ви улесни да изпращате съобщения на хората.

Пример за файл указател:
tinko s61966
minko s881234
ginko s62000
dinko s77777

Примерно извикване на програмата:
./send_message myAddressBook dinko

И вече може да изпращате съобщения на човека с username s77777

NB! Можете да създавате нови потребители използвайки 'sudo useradd username'. За да проверите дали се пращат съобщенията отворете 2 сесии към виртуалката ви, създайте новият потребител, логнете се с него ( 'sudo su username' от едната сесия ) и от другата сесия пратете съобщението.

-- 05-b-4301
Напишете shell script, който автоматично да попълва файла указател от предната задача по подадени аргументи: име на файла указател, пълно име на човека (това, което очакваме да е в /etc/passwd) и избран за него nickname.
Файлът указател нека да е във формат:
<nickname, който лесно да запомните> <username в os-server>
// може да сложите и друг delimiter вместо интервал

Примерно извикване:
./pupulate_address_book myAddressBook "Ben Dover" uncleBen

Добавя към myAddressBook entry-то:
uncleBen <username на Ben Dover в os-server>

***Бонус: Ако има няколко съвпадения за въведеното име (напр. има 10 човека Ivan Petrov в /etc/passwd), всички те да се показват на потребителя, заедно с пореден номер >=1,
след което той да може да въведе някой от номерата (или 0 ако не си хареса никого), и само избраният да бъде добавен към указателя.

More info needed

Напишете shell script, който да приема параметър име на директория, от която взимаме файлове, и опционално експлицитно име на директория, в която ще копираме файлове. Скриптът да копира файловете със съдържание, променено преди по-малко от 45 мин, от първата директория във втората директория. Ако втората директория не е подадена по име, нека да получи такова от днешната дата във формат, който ви е удобен. При желание новосъздадената директория да се архивира.

#!/bin/bash
read dir1
read dir2
if (test -d $dir2);then
        true
else mkdir -p "$dir2"
fi
find $dir1 -type f -cmin -45 -exec cp "{}" $dir2 \;
tar -cvJf test.tar $dir2 2>/dev/null

Да се напише shell скрипт, който получава при стартиране като параметър в командния ред идентификатор на потребител. Скриптът периодично (sleep(1)) да проверява дали потребителят е log-нат, и ако да - да прекратява изпълнението си, извеждайки на стандартния изход подходящо съобщение.

#!/bin/bash
var="$(w|cut -d " " -f 1| grep "$1"|wc -l)"
while true

do 
	if (test $var = "0");
	then
echo "not logged in, Ctrl+C to exit"
		sleep 1s
else 
	echo "User has logged in"
	break
	fi
done

Да се напише shell скрипт, който валидира дали дадено цяло число попада в целочислен интервал.
Скриптът приема 3 аргумента: числото, което трябва да се провери; лява граница на интервала; дясна граница на интервала.
Скриптът да връща exit status:
- 3, когато поне един от трите аргумента не е цяло число
- 2, когато границите на интервала са обърнати
- 1, когато числото не попада в интервала
- 0, когато числото попада в интервала

#!/bin/bash
echo "Enter a testing number:"
read number
echo "Enter a lower limit"
read low
echo "Enter an upper limit"
read high
regex="^[0-9]*$"

if (echo "$number$low$high" | grep "$regex")&>/dev/null;
then
	if (test $high -gt $low);
	then
             if (test $low -le $number && test $high -ge $number);
             then exit 0
             else
             exit 1
             fi

        else
	exit 2
	fi
else exit 3
fi

Да се напише shell скрипт, който форматира големи числа, за да са по-лесни за четене.
Като пръв аргумент на скрипта се подава цяло число.
Като втори незадължителен аргумент се подава разделител. По подразбиране цифрите се разделят с празен интервал.

#!/bin/bash
if (test -z "$2");
then
echo "$1"|sed ":a;s/\B[0-9]\{3\}\>/ &/;ta"
else
	echo "$1"|sed ":a;s/\B[0-9]\{3\}\>/$2&/;ta"
fi

NB sed e kopiran ot internet - needs explaination

Да се напише shell скрипт, който приема файл и директория. Скриптът проверява в подадената директория и нейните под-директории дали съществува копие на подадения файл и отпечатва имената на намерените копия, ако съществуват такива.

#!/bin/bash

echo "Enter a directory"
read dir
echo "enter a file"
read file
find $dir -maxdepth 2 -type f -exec md5sum {} \; | grep "$(md5sum $file|cut -d " " -f 1) "| cut -d " " -f 3

Да се напише shell script, който генерира HTML таблица съдържаща описание на потребителите във виртуалката ви. Таблицата трябва да има:
- заглавен ред с имената нa колоните
- колони за username, group, login shell, GECKO field (man 5 passwd)

not applicable

Да се напише shell скрипт, който получава единствен аргумент директория и изтрива всички повтарящи се (по съдържание) файлове в дадената директория. Когато има няколко еднакви файла, да се остави само този, чието име е лексикографски преди имената на останалите дублирани файлове.

sed explaination to reverse word order from md5sum output needed

Да се напише shell скрипт, който получава единствен аргумент директория и отпечатва списък с всички файлове и директории в нея (без скритите).
До името на всеки файл да седи размера му в байтове, а до името на всяка директория да седи броят на елементите в нея (общ брой на файловете и директориите, без скритите).

a) Добавете параметър -a, който указва на скрипта да проверява и скритите файлове и директории.

#!/bin/bash

find $1 -maxdepth 1 -type f -exec stat -c %n,%s {} \;
find $1 -maxdepth 1 -type d -exec $(ls -l {}| tail -n +2| wc -l)  \;

parviq find raboti, vtoriq ne, za6to?

а се напише shell скрипт, който приема произволен брой аргументи - имена на файлове или директории. Скриптът да извежда за всеки аргумент подходящо съобщение:
	- дали е файл, който може да прочетем
	- ако е директория - имената на файловете в нея, които имат размер, по-малък от броя на файловете в директорията.

#!/bin/bash
while (($#)); 
do
       if (test -f $1 && test -r $1); then
       echo "$1 file is readable"
       else echo "file is not readable or isn not a regular file"
       fi
        if (test -d $1);
	then
		cd $1
		for name in $1/*; do 
			if (test $(stat -c %s $name) -lt $(ls -la| tail -n +2| wc -l));
	                then echo "$1 - $name"
	                fi
                done
	fi

    shift
done

Za6to ima * vav for loop?

Напишете shell script guess, която си намисля число, което вие трябва да познате. В зависимост от вашия отговор, програмата трябва да ви казва "надолу" или "нагоре", докато не познате числото. Когато го познаете, програмата да ви казва с колко опита сте успели.

#!/bin/bash
Guess=$(($RANDOM%20+0))
tries=0
while (test $tries -lt 22)
do
	read lemmetry
	if (test $Guess -ne $lemmetry);
	then echo "Not correct, try again"
		tries=$((tries+1))
	else echo "Correct"
		tries=$((tries+1))
		break
	fi
done

echo "you have succeeded in $tries tries"

Za6to za inkrementacita trqbvat dvoini skobi?

Да се напише shell скрипт, който приема параметър - име на потребител. Скриптът да прекратява изпълненито на всички текущо работещи процеси на дадения потребител, и да извежда колко са били те.

ne6to ot sorta na ps -U $1|cut -d " " -f 3|xargs kill
 (cut ne raboti mnogo pravilno...)

Kato vtora komanda ps -U $1|cut -d " " -f 3| wc -l

ne iskam da go testvam, za6toto 6te prekrati vsi4ko

Да се напише shell скрипт, който приема два параметъра - име на директория и число. Скриптът да извежда сумата от размерите на файловете в директорията, които имат размер, по-голям от подаденото число.

#!/bin/bash
sum =0
for count in $(find $1 -maxdepth 1 -type f -exec du -b {} \;|cut -d "	" -f 1)
do
	if (test $count -gt $2);
	then
		sum=$((count+sum))
	fi
done

echo "The sum is $sum bytes"

Да се напише shell скрипт, който намира броя на изпълнимите файлове в PATH.
Hint: Предполага се, че няма спейсове в имената на директориите
Hint2: Ако все пак искаме да се справим с този случай, да се разгледа IFS променливата и констуркцията while read -d

#!/bin/bash

find $PATH -maxdepth 1 -executable|wc -l

maybe?

Напишете shell script, който получава като единствен аргумент име на потребител и за всеки негов процес изписва съобщение за съотношението на RSS към VSZ. Съобщенията да са сортирани, като процесите с най-много заета виртуална памет са най-отгоре.

Hint:
Понеже в Bash няма аритметика с плаваща запетая, за смятането на съотношението използвайте командата bc. За да сметнем нампример 24/7, можем да: echo "scale=2; 24/7" | bc
Резултатът е 3.42 и има 2 знака след десетичната точка, защото scale=2.
Алтернативно, при липса на bc ползвайте awk.

Skipping I guess?

Опишете поредица от команди или напишете shell скрипт, които/който при известни две директории SOURCE и DESTINATION:
- намира уникалните "разширения" на всички файлове, намиращи се някъде под SOURCE. (За простота приемаме, че в имената на файловете може да се среща символът точка '.' максимум веднъж.)
- за всяко "разширение" създава по една поддиректория на DESTINATION със същото име
- разпределя спрямо "разширението" всички файлове от SOURCE в съответните поддиректории в DESTINATION

#!/bin/bash
find  $1 -name "*\.*"|sed "s/\(^.*\)\(\..*$\)/\2/g"| sort -d| uniq|xargs -I{} mkdir -p $2/{}
cp $(find $1 -maxdepth 1| grep -F "$(find  $1 -name "*\.*"|sed "s/\(^.*\)\(\..*$\)/\2/g"| tail -n +2)") $(find  $1 -name "*\.*"|sed "s/\(^.*\)\(\..*$\)/\2/g"| sort -d| uniq)

parvata komanda ba4ka, vtorata ne, idei?

Да се напише shell скрипт, който получава произволен брой аргументи файлове, които изтрива.
Ако бъде подадена празна директория, тя бива изтрита. Ако подадения файл е директория с поне 1 файл, тя не се изтрива.
За всеки изтрит файл (директория) скриптът добавя ред във log файл с подходящо съобщение.

а) Името на log файла да се чете от shell environment променлива, която сте конфигурирали във вашия .bashrc.
б) Добавете параметър -r на скрипта, който позволява да се изтриват непразни директории рекурсивно.
в) Добавете timestamp на log съобщенията във формата: 2018-05-01 22:51:36

Примери:
$ export RMLOG_FILE=~/logs/remove.log
$ ./rmlog -r f1 f2 f3 mydir/ emptydir/
$ cat $RMLOG_FILE
[2018-04-01 13:12:00] Removed file f1
[2018-04-01 13:12:00] Removed file f2
[2018-04-01 13:12:00] Removed file f3
[2018-04-01 13:12:00] Removed directory recursively mydir/
[2018-04-01 13:12:00] Removed directory emptydir/


Kak stava tova? qsno e 4e 6te se polzva rm i predpolagam ($#) za da obhodi vsi4ki argumenti, no log file?

(Цветно принтиране) Напишете shell script color_print, който взима два параметъра.

Първият може да е измежду "-r", "-g" "-b", а вторият е произволен string.
На командата "echo" може да се подаде код на цвят, който ще оцвети текста в определения цвят.
В зависимост от първия аргумент, изпринтете втория аргумен в определения цвят:

"-r" е червено. Кодът на червеното е '\033[0;31m' (echo -e "\033[0;31m This is red")
"-g" е зелено. Кодът на зеленото е '\033[0;32m' (echo -e "\033[0;32m This is green")
"-b" е синьо. Кодът на синьото е '\033[0;34m' (echo -e "\033[0;34m This is blue")
Ако е подадена друга буква изпишете "Unknown colour", а ако изобщо не е подаден аргумент за цвят, просто изпишете текста.

Hint:

В края на скрипта си напишете:
echo '\033[0m'
,за да не се прецакат цветовете на терминала. Това е цветът на "няма цвят".

#!/bin/bash

if (test "$1" = "-r"); then
   echo -e "\033[0;31m $2"
elif (test "$1" = "-g"); then
 echo -e "\033[0;32m $2"
elif (test "$1" = "-b"); then
        echo -e "\033[0;34m $2"
else echo -e "Unknown colour"
fi
echo -e "\033[0m"

Този път програмата ви ще приема само един параметър, който е измежду ("-r", "-b", "-g", "-x").
Напишете shell script, който приема редовете от stdin и ги изпринтва всеки ред с редуващ се цвят. Цветовете вървят RED-GREEN-BLUE и цветът на първия ред се определя от аргумента.
 Ако е подаден аргумент "-x", то не трябва да променяте цветовете в терминала (т.е., все едно сте извикали командата cat).

Hint: Не забравяйте да връщате цветовете в терминала.

kato predniq script no v cikal kadeto iterirame redovete... Kak stava? hed|tail?
